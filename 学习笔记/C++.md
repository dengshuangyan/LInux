## 动态库与静态库



### 静态链接

源程序经过编译器生成目标文件，目标文件和库一起生成最终的可执行文件。链接的过程就是把分布在各个可重定位的目标文件中相应的节合并起来，同时完成符号解析和重定位。

### 静态链接的缺点：

- 内存浪费，当多个程序需要同一个库文件时，在内存中就会存在多个该库文件的副本。
- 更新困难，当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序，

### 静态链接优点

​	因为可执行程序中已经具备了所有执行程序所需要的任何东西，所以在执行的时候运行速度快。



## 动态库

为了解决静态库的缺点，从而设计了共享库也就是动态库。

动态库在程序编译时不会被链接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么内存里只需要一份该共享库的实例，规避了空间浪费的问题。动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布页带来的麻烦，用户只需要更新动态库就可以，增量更新。

### 动态库原理

​	动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。下面简单介绍动态链接的过程：

​    假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。

​	动态库在链接过程中，不会一块生成可执行文件，会保存一些动态库相关的信息，比如动态库在哪，动态库的名字

### 动态库优点

- 共享一份库文件，即使有多个程序依赖同一个文件，该库也还不会再生成其他副本。
- 更新比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再链接一边。

### 动态库与静态库的区别

- 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。
- 动态库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入，因此在程序运行时还需要动态库的存在。
- 静态库浪费内存，更新麻烦，而动态不会。









## 并行与并发

### 并行

​	指在同一时刻，有多条指令在多个处理器上同时执行。

### 并发

​	指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上不是同时执行的，指示把时间分成若干段，使多个进程快速交替的执行。









## C++内存管理

```c++
// malloc
void *p = malloc(512)
free(p);

int * p = new int;
delete p;

void *p = ::operator new(512)
::operator delete(p) // ::operator new 可以重载
// 还可以使用分配器
```







## mac 与  ip地址









## ARP协议











## TCP 与 UDP

TCP：传输控制协议，面向连接的，可靠的，基于字节流的，但是仅支持单播传输

UDP：用户数据报协议，面向无连接的，不可靠的，面向数据报，支持一对多，一对一，多对多。

server端 socket() ---> bind() 绑定ip和port -----> listen() 监听是否有客户端请求  ---->  accept() 接受客户端连接，成功则返回一个文件描述符

client端：socket()  ------->  connect()在连接的时候会自动绑定接口  -------> send()



listen()函数，在服务器中会有一块缓存区，当有客户端连接时，缓存区中会有数据，

read()函数，返回值为-1：读取失败； 返回值为0：客户端断开连接； 返回值大于0，在读取数据



==服务器和客户端都有tcp的发送缓存区和接收缓存区==

