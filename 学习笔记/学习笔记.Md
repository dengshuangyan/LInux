### 什么是jwt?

   Json web token(JWT),是为了在网络应用环境见传递声明而执行的一种基于json的开放标准（RFC 7519），该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录场景。

​	jwt的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其他业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

### token 和session的区别

#### 1.session

​	session是因为http协议是一种无状态的协议，这也就意味着如果用户在应用上要登陆的话，服务器不会记录用户的信息，所以下一次的请求中，用户还是要进行用户认证。这个时候session就出现了。为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器中存储一份用户登录信息，这份登录信息会在响应的时候传递给游览器，告诉它要保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自于哪个用户了，这就是传统的基于session认证。

但是这种基于session的认证使应用本身很难得到扩展，随着不用客户端用户的增加，独立的服务器已无法承载更多的用户。而这是基于session的认证应用的问题就会暴露出来。

####  2.session的缺点

session本身：每个用户经过应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次的请求，通常而言session都是保存在内存中的，而随着认证用户的增加，服务端的开销会明显的增大。

扩展性：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权资源，这样在分布式的应用上，就会相应的限制负载均衡器的能力，这也意味着限制了应用的扩展能力。

CSRF：因为是基于cookie来进行用户识别，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。

#### 3.token的鉴权机制

​	基于token的鉴权机制类似于http协议，但是太不需要在服务器端保存用户的认证信息或者会话信息。这就意味着基于token的认证机制的应用不需要考虑用户在哪一台服务器上进行登录了，这就为应用的扩展提供了便利。

#### 4.token授权机制的流程

- 用户使用用户名和密码来请求服务器
- 服务器进行验证用户的信息
- 服务器通过验证发送给用户一个token
- 客户端存储token并在每次请求时附送上这个token值
- 服务端验证token值，并返回数据。

这个token必须要在每次请求时传递给服务器，它应该保存在请求头里。



### 什么是断点续传？

​		FTP客户端软件断点续传指的是在下载或上传时，将下载或上传任务（一个文件或者一个压缩包）认为的划分为几个部分，每个部分采用一个线程进行上传或下载，如果碰到网络故障时，可以从已经上传或下载的部分开始继续上传或下载未完成的部分未完成的部分，而没必要从头开始上传下载。这样用户就可以节省时间，提高速度。

总的来说，就是将文件划分为好几个部分，一个部分就用一个线程来上传或下载，这在个传输过程中如果发生了网络故障，恢复的时候就不用从头开始了，只需要从未完成部分开始进行传输，这样就可以提高传输速度。



### 什么心跳检测（服务器）？

​		客户端定时每X秒向服务端发送特定的数据，服务端设定为X秒没有收到客户端心跳则认为客户端掉线，并关闭链接触发onClose回调。这样即通过心跳检测请求维持了连接（避免连接因为长时间不活跃而被网关防火墙关闭），也能让服务端比较及时的知道客户端是否异常掉线。



### 什么是gRPC？？

#### 什么是rpc？		

​	在了解grpc之前要了解一下什么是rpc，因为grpc是rpc的一种。

​	RPC(remote procedure call)远程过程调用。简单的理解是一个节点请求另一个节点提供服务。

​	让我们来对比一个本地过程调用和远程过程调用。

- 本地过程调用：如果需要将本地student对象的age+1，那么就可以实现一个addAge()方法，将student对象传入，对年龄进行更新之后返回就可以了，本地方法调用的函数可以通过函数指针来指定。
- 远程过程调用：上述操作的过程中，如果addAge()这个方法在服务端，执行函数的函数体在远程机器上，如何告诉机器需要调用这个方法？

1. 首先客户端需要告诉服务器，需要调用的函数，这里函数和进程id存在一个映射，客户端远程调用时，需要查一下函数，找到对应的id，然后执行函数的代码。

2. 客户端需要把本地参数传给远程函数，本地调用的过程中，直接讲压入栈就可以了，单数在远程调用过程中不在同一个内存里，无法直接传递函数的参数，

   因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流装换成自身能读取的格式，是一个序列化和反序列化的过程。

3. 数据准备好了，如何进行传输呢，网络传输层需要把调用的id的序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此tcp层即可完成上述过程，但是grpc中采用的是HTTP2协议。

总的来说上面的过程是这样的：

```makefile
# client 端
# Student student = call(ServerAddr, addAge, student);
# 1.将这个调用映射为call Id
# 2.将call Id，student（parms）序列化，以二进制形式打包
# 3.把2中得到的数据包发送给ServerAddr，这需要使用网络传输层
# 4.等待服务器返回结果
# 5.如果服务器调用成功，那么就将结果反序列化，并赋值给student，年龄更新

# server端
# 1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map<String, Method> callIdMap
# 2. 等待客户端请求
# 3. 得到一个请求后，将其数据包反序列化，得到Call ID
# 4. 通过在callIdMap中查找，得到相应的函数指针
# 5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果
# 6. 将student结果序列化后通过网络返回给Client
```



#### 服务方法

grpc提供了四种服务方法，指定了他们的请求和响应类型。

```c++
rpc 方法(客户端/请求) returns (服务端/响应) {}
```



- 一个简单的prc，客户端使用存根想服务器发送请求并等待响应返回，就像普通的函数调用一样。

  ```c++
  rpc GetFeature(Point) returns (Feature){};
  ```

- 服务器端流rpc，其中客户端发送请求到服务器，并获取一个流以读回一系列消息。客户端读取返回的流，直到没有更多的消息。根据==stream==来确认。

  ```c++
  rpc RecordRoute(Rectangle) returns (stream Feature)
  ```

- 客户端流传输的rpc，其中客户端将消息写入序列，并将它们发送到服务端，再次使用提供的流，一旦客户端完成写入消息，它等待服务器读取所有的消息并返回对应的响应，你可以通过==stream==在请求类型之前放置关键字来指定客户端流方法。

  ```c++
  rpc RecordRoute(stream Point) returns (RouteSummary) {}
  ```

- 一个双向rpc双方都派出读写流的消息序列，这两个流独立运行，因此客户端和服务器可以按照它们喜欢的任何顺序进行读写，例如服务器可以在写入响应之前等待接受所有客户端消息，或者它可以交替读取消息然后写入消息，或其他一些读取和写入的组合，保留每个流中的消息的顺序。你可以通过stream在请求和响应之前放置关键字来指定这种类型的方法。

  ```c++
  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
  ```

  根据.proto文件生成定义的grpc客户端和服务器接口。

  ```c++
  route_guide.pb.h       // 声明您生成的消息类的标头
  route_guide.pb.cc      //其中包含您的消息类的实现
  route_guide.grpc.pb.h  //声明您生成的服务类的标头
  route_guide.grpc.pb.cc //其中包含您的服务类的实现
  ```

  

### std::bind 和 std::placeholders

头文件：#include <functional> ,它是一个函数适配器，接受一个可调用的对象，生成一个新的可调用对象来“适应”原对象的参数列表。

std::bind()函数有两个函数原型，定义如下,std::bind()函数绑定

template<calss F,class...Args>
/*  unspecified  */ bind(F && f,Args&&... args );

template <class R,class F,class... Args >
/****unspecified**/ bind( F&& f,Args&&... args);

std::bind()返回宇哥基于f的函数对象，其参数被绑定到args上，f的参数要么被绑定到placeholders（占位符，如\_1,\_2,\_n.....)。
std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。

#### 1.bind绑定普通函数

```c++
double cal(double x,double y){ return x + y;}
auto fun1 = std::bind(cal,std::placeholders::_1,2);
std::cout << fun1(10) << endl;
```

					- bind函数的第一个参数是函数名，普通函数做实参时，会隐式的换成函数指针。因此std::bind(cal,_1,2)，等价于std::bind(&cal,\_1,2);
   - _1表示占位符，位于<funtional>头文件中，std::placeholders::\_1
   - 第一个参数被占位符占用，表示这个参以调用时传入的参数为准，在这里调用了cal时，给它传入了10，其实就是相当于调用了cal(10,2);

#### 2.std::bind 绑定一个成员函数

```c++
calss test{
    double cal(double x,double y){ return x + y; }
    int data = 30;
}
int main()
{
    test t;
    auto fun2 = std::bind(&test::cal,&t,10,std::placeholders::_1);
    fun2(20);// 输出30
}
```

- bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址。
- 必须显示的指定&test::cal,因为编译器不会将对象的成员函数隐式的转换成函数指针，所以必须在test::cal前面添加&取地址符。
- 使用对象成员函数的指针时，必须要知道该指针属于哪个对象，因此第二个参数为对象的地址&t。

#### 3.std::bind绑定一个引用参数

1. std::ref 用于包装按引用传递的值。
2. std::cref 用于包装按常量引用传递的值。

```c++
int cal(int& a,const int& b){ return a + b; }
int main()
{
    int a = 1,b = 2;
    auto fun3 = std::bind(cal,std::ref(a),std::cref(b));
    return 0;
}
```

默认情况下，bind的那些不是站位符的参数被**<u>拷贝</u>**到bind返回的可调用函数对象中，当需要把对象传到bind中的参数时，需要使用ref或者cref

```c++
void Same(int &a,int b) {  a = b ;}
int main()
{
    int a = 5;
    auto fun4 = std::bind(Same,a,std::placeholders::_1);  // 此处bind中的参数a只是a的一个值拷贝，而不是a的引用
    fun4(9); //此处的a仍然为5
    auto fun5 = std::bind(Same,ref(a),std::placeholders::_1);
    fun5(9);
    cout << a << "\n"; // 此时a为9了。
    return 0;
}
```

- std::bind 预先绑定的参数需要传递具体的变量或者值进去，同时此过程是值传递，如果想以引用传递的形式进行传递，则需要使用std::ref或者std::cref
- 若不想预先传值，则需要占位符，从std::placeholders::\_1开始，逐步递增，此过程为引用传递。

### 什么是可调用对象？

- 是一个函数指针
- 一个类成员函数指针
- 可被转换成函数指针的类对象
- 是一个具有operator()成员函数的类的对象

### 什么是function ??

function封装函数，是一种通用，多态的函数封装。可容纳各种可调用对象，例如普通函数、函数指针、Lambda表达式以及std::bind表达式等。换句话说，可以当作是函数的容器。对于类型不安全的函数指针来说，将其封装成一个安全的std::function对象是一个良好的选择。







### Qt中的Qvariant类型

Qvatiant这个类很神奇，或者说方便，很多时候，需要几种不同数据类型需要传递，如果用结构体的话，又不太方便，容器保存的也是一种类型，而Qvariant则可以统统搞定。 Qvariant可以保存很多Qt的数据类型，也可以支持自定义的数据类型。





### 什么是事务回滚？

#### 事务的定义

​	事务是由单独单元的一个或者多个sql语句组成，在这个单元中，每个mysql语句都是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条sql语句一旦执行失败或者产生错误，整个单元将会回滚，所有受到影响的数据将会返回到事务开始以前的状态；如果单元中所有的sql与居家均执行成功，则事务被顺利执行。

#### 事务的四个属性：

- 原子性 A：一个事务不可再分割，要么全部都要执行，要么全部都不执行。
- 一致性 C：一个事务的执行会使数据从一个一致状态切换到另一个一致的状态。
- 隔离性 I：一个事务的执行不受其他事务的干扰。
- 持久性 D：一个事务一旦提交，则会永远的改变数据库的数据

这四个属性简称为ACID特性。

​		MYsql事务主要是用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，删除一个人员，你需要删除人员的基本资料，也要删除和该人员相关的信息，比如文章，信箱，在企业微信中的账号，等等。

- mysql中只有insert,update,delete.语句才有事务。
- 事务处理可以用来维护数据库的完整性，保证成批的sql语句要么全部执行，要么全部不执行。
- BEGIN    开始一个事务
- ROLLBACK  事务回滚
- COMMIT    事务确定    这三个都是命令

#### 事务引起的问题

##### 脏读

​	事务A读取到了事务B已经修改但尚未提交的数据，如果事务B回滚，A读取的数据与上次不一致；不符合事务的一致性要求。

##### 不可重复读

​	事务A读取到了事务B已经提交的修改数据，不符合隔离性。

##### 幻读

​	事务A读取到了事务B提交的新增数据，不符合隔离性。





### Linux中的环境变量

#### 环境变量的含义
​				**环境变量的含义**：环境变量一般是指操作系统中指定操作系统运行环境的一些参数。它相当于一个指针，想要查看变量的值，需要加上$

#### 环境变量的分类

在linux系统中，环境变量**按照其作用范围**不同大致可以分为系统环境变量和用户级环境变量。

- 系统级环境变量：每一个登录到系统的用户都能读取到系统级的环境变量。
- 用户级环境变量：每一个登录到系统的用户只能读取属于自己的环境变量。

自然而然地，环境变量的配置文件也相应的被分为系统级和用户级两种。

**按作用的范围分**
在Linux中的变量，可以分为环境变量和本地变量：
1）环境变量：相当于全局变量，存在于所有的Shell中，具有继承性；
2）本地变量：相当于局部变量只存在当前Shell中，本地变量包含环境变量，非环境变量不具有继承性。
 **按生存周期分**
1）永久：需要修改配置文件，变量永久生效；
2）暂时：使用**export**定义，关闭Shell后失效。

环境变量的组织方式，看下图：

![image-20210730112030773](C:\Users\wsrnd\AppData\Roaming\Typora\typora-user-images\image-20210730112030773.png)

每个程序都有一张环境表，环境表是一个字符指针数组，每一个指针指向一个以‘\0’结尾的环境字符串。



#### **常见的环境变量**

**PATH**

该变量指定命令的搜索路径：
![image-20210730112630256](C:\Users\wsrnd\AppData\Roaming\Typora\typora-user-images\image-20210730112630256.png)

从中可以看出，在当前目录下，PATH的值。它表示在当前目录下执行的每一条指令的搜索路径，每个目录以冒号隔开。当执行一条指令时，系统就会从系统文件中去寻找，找到了就执行；否则不执行。

**SHELL** :该变量指定用户当前使用的解析器。

**HOSTNAME**: 该变量指定主机名。

**LOGNAME** : 该变量指定显示用户的登录名。

**HISTSIZE**:该变量指定保存历史命令的数目。



#### 修改和显示环境变量的命令

echo:该命令用于显示某个环境变量的值。

env：该命令指定显示所有的环境变量和值。

set：该命令指定本地变量

export：该命令指定设置一个新的环境变量。

unset：该命令指定清除环境变量

readonly：该命令用于设置只读环境变量。 将环境变量设置为只读模式后，就不能在对它进行修改了，直到用户退出登录后才有效。



#### 存放环境变量的文件

**/etc/profile**
该文件的作用是当用户登录时获取系统的环境变量，只获取一次。

 **/etc/bashrc**
当执行完/etc/profile文件后，用户想打开bash Shell就会读取该文件。如果想每次打开bash Shell后都执行某些操作，可以在该文件中设置。

**~/.bash_profile**
每个用户都可使用该文件输入专用于自己使用的shell信息。当用户登录时，该文件仅仅执行一次，默认情况下，它设置一些环境变量，执行用户的.bashrc文件。
单个用户此文件的修改只会影响到他以后的每一次登陆系统。因此，可以在这里设置单个用户的特殊的环境变量或者特殊的操作，那么它在每次登陆的时候都会去获取这些新的环境变量或者做某些特殊的操作，但是仅仅在登陆时。

**~/.bashrc**
该文件包含专用于单个人的bash shell的bash信息，当登录时以及每次打开一个新的shell时,该该文件被读取。
单个用户此文件的修改会影响到他以后的每一次登陆系统和每一次新开一个bash。因此，可以在这里设置单个用户的特殊的环境变量或者特殊的操作，那么每次它新登陆系统或者新开一个bash，都会去获取相应的特殊的环境变量和特殊操作。

 **~/.bash_logout**
当每次退出系统(退出bash shell)时,执行该文件。

**可以通过代码来获取环境变量。**

**可以通过第三方变量environ获取**

**通过系统调用获取或设置环境变量**















### Linux下的多线程

**线程的优点**（相对于进程）

- 创建和销毁的开销更小。
- 切换调度的开销更小。
- 占用的资源更小。

这些都是因为线程公用同一块虚拟地址空间。 （全局变量会因为线程影响）

**线程的缺点**

- 健壮性较低（一个线程异常终止会导致进程异常终止）
- 编程（调试）难度较大，也容易导致线程安全问题。





#### **线程相关函数**

**创建线程函数**  ：

```c++
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(* start_routine) (void *), void *arg);
read_t *thread // 所创建线程的id，是一个输出型的参数。
const pthread_attr_t *attr // 设置线程属性，一般为NULL.
void *(*start_routine) (void *) //参数和返回值都为void*的函数指针，相当于这个新线程的入口函数，将指定这个新线程执行哪段代码。
void *arg //上一个参数--入口函数的参数。

```

如果创建一个进程，需要两个入口函数，应该怎么办？
		可以将函数手动包含在一个结构体中，将结构体地址传入即可。



```C++
#include <iostream>
#include "zlog.h"

int main() {
    int rc;
    zlog_category_t *c;

    rc = zlog_init("../zlog.conf");
    if (rc) {
        std::cout<< rc << std::endl;
        printf("init failed\n");
        return -1;
    }
    c = zlog_get_category("my_cat");
    if (!c) {
        printf("get cat fail\n");
        zlog_fini();
        return -2;
    }
    zlog_info(c, "hello, info");
    zlog_debug(c, "hello, debug");
    zlog_warn(c, "hello warn");
    zlog_error(c, "hello error");

    zlog_fini();

    return 0;
}

```





#### 线程的终止

- 线程入口函数结束
- 调用了函数pthread_exit()-------结束本线程（ps：哪个线程调用该函数，哪个线程结束）
- exit会导致整进程的退出。



#### 线程资源回收

​		线程有joinable和unjoinable两种状态，如果线程是joinable状态，当子线程的主函数终止时（自己退出或者是调用pthread_exit退出），不会释放线程所占用的内存资源，这种线程称为“僵尸进程”，

​		创建线程时默认属性连接的是joinable，是非分离的。



#### 等待函数（阻塞函数）

```C++
int pthread_join(pthread_t thread, void **retval)
pthread_t thread // 要等待的线程
void ** retval  // 输出型参数，一般为NULL
// 如果等待的线程一直不结束，那么这个函数会一直阻塞，实质是为了等待线程结束在执行后面的代码，控制执行逻辑。
```





#### 线程的分离

当pthread_join函数等待的线程不结束时，pthread_join函数会一直等待阻塞，然而我们并不希望这样的情况产生，但是线程结束后的资源又必须回收，所以这时候就可以采用线程分离，该线程结束后会自动释放资源，它类似于忽略SIGCHLD信号，即父进程仍下子进程不管。

分离函数：

```c++
int pthread_detach(pthread_t thread);
pthread_t thread // 分离的线程号。
```

#### 查看线程状态

​		在linux中可以使用一下命令来查看线程信息。

- ps xH 查看所有存在的线程。
- ps -mp <PID> 查看一个进程起的线程数
- top -H 









### C++中的指针

#### 指针函数

指针函数，简单的来说就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。

```C++
int* sum(int a,int b);
```



#### 函数指针

函数指针，其本质是一个指针变量，该指针指向这个函数。简单的讲，函数指针就是指向函数的指针 。

```C++
int add(int a,int b);
int (*p)(int a, int b);//p就是指向add函数的指针。
```









### Protocol Buffer（协议缓冲区）

protocol buffer 结构序列化工具，通过将结构化的数据（拥有多种属性）进行序列化，从而实现（内存与硬盘之间）数据存储和交换的功能。

- 序列化：按照.proto协议文件将数据结构或对象转换成二进制流的过程。
- 反序列化：将在序列化过程中所生成的二进制流转换成数据结构和对象的过程。













### LINUX下的多进程

进程

进程就是正在内存中运行的程序，Linux中的一个进程在内存中有三个部分的数据，”代码段“、”堆栈段“、”数据段“。

- 代码段：就是存放代码的内存
- 堆栈段：存放的是程序的返回地址、程序的参数以及程序的局部变量。
- 数据段：就是存放程序的全局变量、常数以及动态数据分配的数据空间（比如new函数分配的空间）。

系统如果运行多个相同的程序，他们的代码段是相同的，但是它们的堆栈段和数据段是不同的。



#### 查看进程命令

- ps     ------- 查看当前终端的进程(这里仅仅是ps)
  ![image-20210803144935625](C:\Users\wsrnd\AppData\Roaming\Typora\typora-user-images\image-20210803144935625.png)

- ps -ef  ------ 查看系统的全部进程
  ![image-20210803145046889](C:\Users\wsrnd\AppData\Roaming\Typora\typora-user-images\image-20210803145046889.png)

  

- ps -ef | more   ----- 查看系统全部的进程，结果分页显示，退出可以按q
- ![image-20210803145208717](C:\Users\wsrnd\AppData\Roaming\Typora\typora-user-images\image-20210803145208717.png)



| 名称  |       代表的含义       |
| :---: | :--------------------: |
|  UID  | 启动进程的操作系统用户 |
|  PID  |        进程编号        |
| PPID  |    进程的父进程编号    |
|   C   |  CPU使用的资源百分比   |
| STIME |     进程启动的时间     |
|  TTY  |     进程所属的终端     |
|  CMD  |    执行的是什么指令    |
| TIME  |    使用掉的CPU时间     |

- ps -ef | grep book, 查看系统全部进程，然后从结果集中过滤出包含”book“单词的记录，



#### fork函数

fork函数用于产生一个新的进程，函数返回值pid_t是一个整数，在父进程中，返回值是子进程的编号，在子进程中，返回值是0。

```C++
pid_t fork(); // pid_t 是int的别名。 typedef int pid_t
```

​		fork函数创建了一个新的进程，新进程（子进程）与原有的进程（父进程）一模一样，子进程和父进程使用了相同的代码端，子进程拷贝了父进程的堆栈段和数据段。子进程一旦运行开始，它复制了父进程的一切数据，然后各自运行，相互之间没有影响。

​		fork函数对返回值做了特别的处理，调用了fork函数之后，**在子程序中fork的返回值是0，**在父进程中fork的返回值是子进程的编号，程序员可以通过fork的返回值来区分父进程和子进程，然后再执行不同的代码。

​		fork函数在赋值了父进程的一切后，子进程中的变量发生改变时会不会影响父进程呢，可以通过一下代码来测试：

```c++
// 验证子进程在复制了父进程之后，在子进程中改变变量会不会影响父进程的变量。经过测试，
int main()
{
    int pid = fork();

    int num = 10;
    if(pid)
    {
        cout << " this is father process ! " << endl;
        num = 100;
        int x = 188;
        cout<< num << "  --------------- " << x << endl;
    }
    else
    {
        cout << "this is child process ! " << endl;
        num = 123;
        int x = 1;
        cout << num << " ----------- " << x << endl;
    }
}
```

经过上列代码，发现子进程应该是另外开辟了一个内存空间，不是跟父进程公共一个内存，所以当子进程中的变量发生了变化，并不会影响父进程。

根据上面知识点可以一些练习，如

1. 编写一个示例程序，由父进程生成10个子进程，在子进程中显示它是第几个子进程和子进程本身的进程编号。

```c++
int main()
{
    for(int i = 1;i <= 10;i++)
    {
        int pid = fork();

        if(!pid) break;  //这里很重要，因为不加上在一行代码的话，他就会像递归一样，不止生成十个，

        cout << i << " -------" << pid << endl;
        //break;
    }
    sleep(30); // 这里停下来，主要想看一下进程里面有没有。
    return 0;
}
```

通过这次的练习，可以知道，==子进程会执行在fork函数之后的代码，并不会执行之前的代码==，所以这里有点像递归一样，这样的话，子进程就不会创建子进程。

2. 编写示例程序，由父进程生成子进程，子进程再生成孙进程，共生成第10代进程，在各级子进程中显示它是第几代子进程和子进程本身的进程编号。

```c++
int main()
{
    int pid;
    for(int i = 1;i <= 10 ;i++)
    {
        pid = fork();
        if(pid) break; //与上面相反，因为这次要用子进程创建子进程，阻止父进程创建子进程。

        cout<< i <<  " ----------" << endl;
    }
    sleep(20);
    return 0;
}
```

